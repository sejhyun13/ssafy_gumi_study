
# [BOJ] 15788 - 밸런스 스톤 (Java)

## 🔗 문제 링크
[백준 15788번: 밸런스 스톤](https://www.acmicpc.net/problem/15788)


---
## 📊 성능 분석 (Performance)

| 메모리 (Memory) | 시간 (Time) | 언어 (Language) | 코드 길이 (Code Length) |
| :---: | :---: | :---: | :---: |
| **37196 KB** | **368 ms** | **Java 11** | **1303 B** |


## 📌 문제 개요
가로, 세로, 대각선의 합이 모두 같아야 하는 $N \times N$ 격자에서 딱 하나의 칸이 비어(0으로 표시) 있습니다. 이 비어있는 칸에 들어갈 양의 정수 밸런스 스톤의 값을 찾아내는 문제입니다. 만약 조건을 만족하는 값이 없거나 양의 정수가 아니라면 -1을 출력합니다.



---

## 💡 해결 프로세스
 1. 목표 합계($Sum$) 찾기: 밸런스 스톤(0)이 포함되지 않은 행을 하나 골라, 그 행의 합을 기준 합계($Sum$)로 '설정'합니다.
 2. 스톤 값($ans$) 추론: 기준 합계에서 스톤이 포함된 행의 현재 합을 뺍니다. ($ans = Sum - r[posR]$)
 3. 사전 검사 (Pre-test):
    * '추론한' $ans$를 스톤이 속한 행, 열, 대각선 합에 더합니다.
    * 모든 행의 합이 $Sum$과 같은지 확인합니다.
    * 모든 열의 합이 $Sum$과 같은지 확인합니다.
    * 스톤이 대각선상에 있다면, 대각선의 합도 $Sum$과 같은지 확인합니다.



---

## 💻 코드 구조 상세 (Core Logic)

🔍 데이터 입력 및 위치 파악
```Java
if(map[i][j] == 0) {
    posR = i; posC = j; // 0이 위치한 좌표를 백업
}
r[i] += map[i][j]; // 행 누적합
c[j] += map[i][j]; // 열 누적합
if(i == j) diag1 += map[i][j]; //  대각선1 (\)
if(i + j == n - 1) diag2 += map[i][j]; // 대각선2 (/)
```
⚖️ 기준 합계 도출(추론 합)
```Java
for(int i = 0; i < n; ++i) {
    if(i != posR) { 
        sum = r[i]; // 스톤이 없는 안전한 행의 합을 기준으로 잡음
        break;
    }
}```
✅ 최종 검증 로직
추론한 합과 추론한 밸런스 스톤값을 적용하여, 나머지 모든 선들의 합이 일치하는지 전수 조사가 필요합니다.

```Java
// 밸런스 스톤 값을 적용해보고 모든 합이 일치하는지 체크
ans = sum - r[posR];    
c[posC] += ans; r[posR] += ans;

for(int i = 1; i < n; ++i) {
    if(r[i] != r[i-1]) ans = -1; // 행의 합 불일치 시 탈락
    if(c[i] != c[i-1]) ans = -1; // 열의 합 불일치 시 탈락
}```
---

⚠️ 주의 및 회고
 스톤이 대각선 위에 있지 않더라도, ans를 더한 후의 대각선 합이 기준 sum과 다르면 안 됩니다.(현재 코드는 통과가 되지만 주의)
