깃허브(GitHub)나 개인 블로그에 바로 복사해서 사용하실 수 있도록 백준 2578번 빙고 문제의 README.md 파일을 마크업 언어로 정리해 드립니다.

Markdown
# [BOJ] 2578 - 빙고 (Java)

## 🔗 문제 링크
[백준 2578번: 빙고](https://www.acmicpc.net/problem/2578)

---
## 📊 성능 분석 (Performance)

| 메모리 (Memory) | 시간 (Time) | 언어 (Language) | 코드 길이 (Code Length) |
| :---: | :---: | :---: | :---: |
| **14160 KB** | **112 ms** | **Java 11** | **3,193 B** |

## 📌 문제 개요
5x5 크기의 빙고판에 1부터 25까지의 숫자가 적혀 있습니다. 사회자가 숫자를 하나씩 부를 때마다 해당 숫자에 X표를 합니다. 이때 가로, 세로, 혹은 대각선으로 5개의 숫자가 모두 X표 되면 '빙고' 한 줄이 완성됩니다. 이러한 **빙고 줄이 3개 이상**이 되는 순간, 사회자가 몇 번째 숫자를 불렀는지 구하는 프로그램을 작성합니다.



---

## 💡 주요 설계 (Algorithm Design)

### 1. 빠른 위치 탐색 (`Pair[] cache`)
사회자가 숫자를 부를 때마다 5x5 배열을 전체 탐색하는 것은 비효율적입니다. 
- **해결**: 숫자의 위치(r, c)를 미리 `cache` 배열에 저장하여, 숫자가 불리는 즉시 **$O(1)$**의 시간 복잡도로 좌표를 찾아냅니다.
- `cache[숫자] = new Pair(row, col)`

### 2. 빙고 카운팅 최적화
매번 전체 판을 검사하지 않고, 각 라인의 상태를 저장하는 배열과 변수를 활용합니다.
- `row[5]`, `col[5]`: 각 행과 열에 체크된 숫자의 개수를 기록합니다.
- `crossD`: 왼쪽 위 → 오른쪽 아래 대각선 ($r == c$)의 체크 개수입니다.
- `crossU`: 왼쪽 아래 → 오른쪽 위 대각선 ($r + c == 4$)의 체크 개수입니다.

### 3. 승리 조건 판별 (`check()`)
숫자가 하나 불릴 때마다 `check()` 함수를 호출합니다.
- 각 행(`row`), 열(`col`), 대각선(`cross`) 중 값이 **5**인 항목의 개수를 합산합니다.
- 합계가 **3 이상**이면 빙고가 완성된 것으로 판단하고 결과를 출력합니다.

---

## 💻 코드 구조 상세 (Core Logic)

### 핵심 변수
| 변수 | 타입 | 설명 |
| :--- | :--- | :--- |
| `bingo` | `int[][]` | 5x5 빙고판의 숫자 정보 |
| `cache` | `Pair[]` | 숫자별 좌표(r, c)를 담은 인덱스 배열 |
| `row / col` | `int[]` | 각 행/열에 마킹된 숫자 개수 (최대 5) |
| `crossU / crossD` | `int` | 두 대각선에 마킹된 숫자 개수 (최대 5) |

### 로직 흐름
1. **데이터 입력**: 빙고판을 입력받으며 각 숫자의 좌표를 `cache`에 매핑합니다.
2. **숫자 마킹**: 사회자가 부른 숫자의 좌표를 찾아 해당 라인의 카운트(`++`)를 올립니다.
3. **대각선 체크**:
   - `r == c` 인 경우 하향 대각선 카운트 증가
   - `r + c == 4` 인 경우 상향 대각선 카운트 증가
4. **빙고 판정**: 완성된 줄이 3개 이상이면 진행된 숫자 개수를 출력하고 종료합니다.

---

## 📝 코드 주석 가이드

```java
// 사회자가 부른 숫자의 위치를 cache에서 즉시 참조
int r = cache[nowNo].y;
int c = cache[nowNo].x;

// 해당 위치의 행, 열 카운트 증가
++row[r];
++col[c];

// 대각선 포함 여부 확인 및 카운트 증가
if(r == c) ++crossD;  
if((5 - 1) == r + c) ++crossU;

// 현재 완성된 빙고 줄이 3개 이상인지 테스트
if(check()) {
    // 1-based index로 몇 번째 숫자인지 계산하여 출력
    bw.write(1 + i * 5 + j + ""); 
    return;
}
